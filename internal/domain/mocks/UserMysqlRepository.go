// Code generated by MockGen. DO NOT EDIT.
// Source: internal/user/repository.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	domain "github.com/radyatamaa/dating-apps-api/internal/domain"
	paginator "github.com/radyatamaa/dating-apps-api/pkg/database/paginator"
	gorm "gorm.io/gorm"
)

// UserMysqlRepository is a mock of MysqlRepository interface.
type UserMysqlRepository struct {
	ctrl     *gomock.Controller
	recorder *UserMysqlRepositoryMockRecorder
}

// UserMysqlRepositoryMockRecorder is the mock recorder for UserMysqlRepository.
type UserMysqlRepositoryMockRecorder struct {
	mock *UserMysqlRepository
}

// NewUserMysqlRepository creates a new mock instance.
func NewUserMysqlRepository(ctrl *gomock.Controller) *UserMysqlRepository {
	mock := &UserMysqlRepository{ctrl: ctrl}
	mock.recorder = &UserMysqlRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *UserMysqlRepository) EXPECT() *UserMysqlRepositoryMockRecorder {
	return m.recorder
}

// DB mocks base method.
func (m *UserMysqlRepository) DB() *gorm.DB {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DB")
	ret0, _ := ret[0].(*gorm.DB)
	return ret0
}

// DB indicates an expected call of DB.
func (mr *UserMysqlRepositoryMockRecorder) DB() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DB", reflect.TypeOf((*UserMysqlRepository)(nil).DB))
}

// Delete mocks base method.
func (m *UserMysqlRepository) Delete(ctx context.Context, id int) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, id)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Delete indicates an expected call of Delete.
func (mr *UserMysqlRepositoryMockRecorder) Delete(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*UserMysqlRepository)(nil).Delete), ctx, id)
}

// FetchWithFilter mocks base method.
func (m *UserMysqlRepository) FetchWithFilter(ctx context.Context, limit, offset int, order string, fields, associate, filter []string, model interface{}, args ...interface{}) (interface{}, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, limit, offset, order, fields, associate, filter, model}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FetchWithFilter", varargs...)
	ret0, _ := ret[0].(interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchWithFilter indicates an expected call of FetchWithFilter.
func (mr *UserMysqlRepositoryMockRecorder) FetchWithFilter(ctx, limit, offset, order, fields, associate, filter, model interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, limit, offset, order, fields, associate, filter, model}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchWithFilter", reflect.TypeOf((*UserMysqlRepository)(nil).FetchWithFilter), varargs...)
}

// FetchWithFilterAndPagination mocks base method.
func (m *UserMysqlRepository) FetchWithFilterAndPagination(ctx context.Context, limit, offset int, order string, fields, associate, filter []string, model interface{}, args ...interface{}) (*paginator.Paginator, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, limit, offset, order, fields, associate, filter, model}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FetchWithFilterAndPagination", varargs...)
	ret0, _ := ret[0].(*paginator.Paginator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchWithFilterAndPagination indicates an expected call of FetchWithFilterAndPagination.
func (mr *UserMysqlRepositoryMockRecorder) FetchWithFilterAndPagination(ctx, limit, offset, order, fields, associate, filter, model interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, limit, offset, order, fields, associate, filter, model}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchWithFilterAndPagination", reflect.TypeOf((*UserMysqlRepository)(nil).FetchWithFilterAndPagination), varargs...)
}

// SingleWithFilter mocks base method.
func (m *UserMysqlRepository) SingleWithFilter(ctx context.Context, fields, associate, filter []string, model interface{}, args ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, fields, associate, filter, model}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SingleWithFilter", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SingleWithFilter indicates an expected call of SingleWithFilter.
func (mr *UserMysqlRepositoryMockRecorder) SingleWithFilter(ctx, fields, associate, filter, model interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, fields, associate, filter, model}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SingleWithFilter", reflect.TypeOf((*UserMysqlRepository)(nil).SingleWithFilter), varargs...)
}

// SoftDelete mocks base method.
func (m *UserMysqlRepository) SoftDelete(ctx context.Context, id int) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SoftDelete", ctx, id)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SoftDelete indicates an expected call of SoftDelete.
func (mr *UserMysqlRepositoryMockRecorder) SoftDelete(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SoftDelete", reflect.TypeOf((*UserMysqlRepository)(nil).SoftDelete), ctx, id)
}

// Store mocks base method.
func (m *UserMysqlRepository) Store(ctx context.Context, data domain.User) (domain.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Store", ctx, data)
	ret0, _ := ret[0].(domain.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Store indicates an expected call of Store.
func (mr *UserMysqlRepositoryMockRecorder) Store(ctx, data interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Store", reflect.TypeOf((*UserMysqlRepository)(nil).Store), ctx, data)
}

// StoreWithTx mocks base method.
func (m *UserMysqlRepository) StoreWithTx(ctx context.Context, tx *gorm.DB, data domain.User) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreWithTx", ctx, tx, data)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StoreWithTx indicates an expected call of StoreWithTx.
func (mr *UserMysqlRepositoryMockRecorder) StoreWithTx(ctx, tx, data interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreWithTx", reflect.TypeOf((*UserMysqlRepository)(nil).StoreWithTx), ctx, tx, data)
}

// Update mocks base method.
func (m *UserMysqlRepository) Update(ctx context.Context, data domain.User) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, data)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *UserMysqlRepositoryMockRecorder) Update(ctx, data interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*UserMysqlRepository)(nil).Update), ctx, data)
}

// UpdateSelectedField mocks base method.
func (m *UserMysqlRepository) UpdateSelectedField(ctx context.Context, field []string, values map[string]interface{}, id int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateSelectedField", ctx, field, values, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateSelectedField indicates an expected call of UpdateSelectedField.
func (mr *UserMysqlRepositoryMockRecorder) UpdateSelectedField(ctx, field, values, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateSelectedField", reflect.TypeOf((*UserMysqlRepository)(nil).UpdateSelectedField), ctx, field, values, id)
}

// UpdateSelectedFieldWithTx mocks base method.
func (m *UserMysqlRepository) UpdateSelectedFieldWithTx(ctx context.Context, tx *gorm.DB, field []string, values map[string]interface{}, id int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateSelectedFieldWithTx", ctx, tx, field, values, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateSelectedFieldWithTx indicates an expected call of UpdateSelectedFieldWithTx.
func (mr *UserMysqlRepositoryMockRecorder) UpdateSelectedFieldWithTx(ctx, tx, field, values, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateSelectedFieldWithTx", reflect.TypeOf((*UserMysqlRepository)(nil).UpdateSelectedFieldWithTx), ctx, tx, field, values, id)
}

