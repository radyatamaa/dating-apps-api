// Code generated by MockGen. DO NOT EDIT.
// Source: internal/swipe/repository.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	domain "github.com/radyatamaa/dating-apps-api/internal/domain"
	paginator "github.com/radyatamaa/dating-apps-api/pkg/database/paginator"
	gorm "gorm.io/gorm"
)

// SwipeMysqlRepository is a mock of MysqlRepository interface.
type SwipeMysqlRepository struct {
	ctrl     *gomock.Controller
	recorder *SwipeMysqlRepositoryMockRecorder
}

// SwipeMysqlRepositoryMockRecorder is the mock recorder for SwipeMysqlRepository.
type SwipeMysqlRepositoryMockRecorder struct {
	mock *SwipeMysqlRepository
}

// NewSwipeMysqlRepository creates a new mock instance.
func NewSwipeMysqlRepository(ctrl *gomock.Controller) *SwipeMysqlRepository {
	mock := &SwipeMysqlRepository{ctrl: ctrl}
	mock.recorder = &SwipeMysqlRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *SwipeMysqlRepository) EXPECT() *SwipeMysqlRepositoryMockRecorder {
	return m.recorder
}

// DB mocks base method.
func (m *SwipeMysqlRepository) DB() *gorm.DB {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DB")
	ret0, _ := ret[0].(*gorm.DB)
	return ret0
}

// DB indicates an expected call of DB.
func (mr *SwipeMysqlRepositoryMockRecorder) DB() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DB", reflect.TypeOf((*SwipeMysqlRepository)(nil).DB))
}

// Delete mocks base method.
func (m *SwipeMysqlRepository) Delete(ctx context.Context, id int) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, id)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Delete indicates an expected call of Delete.
func (mr *SwipeMysqlRepositoryMockRecorder) Delete(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*SwipeMysqlRepository)(nil).Delete), ctx, id)
}

// FetchWithFilter mocks base method.
func (m *SwipeMysqlRepository) FetchWithFilter(ctx context.Context, limit, offset int, order string, fields, associate, filter []string, model interface{}, args ...interface{}) (interface{}, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, limit, offset, order, fields, associate, filter, model}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FetchWithFilter", varargs...)
	ret0, _ := ret[0].(interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchWithFilter indicates an expected call of FetchWithFilter.
func (mr *SwipeMysqlRepositoryMockRecorder) FetchWithFilter(ctx, limit, offset, order, fields, associate, filter, model interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, limit, offset, order, fields, associate, filter, model}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchWithFilter", reflect.TypeOf((*SwipeMysqlRepository)(nil).FetchWithFilter), varargs...)
}

// FetchWithFilterAndPagination mocks base method.
func (m *SwipeMysqlRepository) FetchWithFilterAndPagination(ctx context.Context, limit, offset int, order string, fields, associate, filter []string, model interface{}, args ...interface{}) (*paginator.Paginator, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, limit, offset, order, fields, associate, filter, model}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FetchWithFilterAndPagination", varargs...)
	ret0, _ := ret[0].(*paginator.Paginator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchWithFilterAndPagination indicates an expected call of FetchWithFilterAndPagination.
func (mr *SwipeMysqlRepositoryMockRecorder) FetchWithFilterAndPagination(ctx, limit, offset, order, fields, associate, filter, model interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, limit, offset, order, fields, associate, filter, model}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchWithFilterAndPagination", reflect.TypeOf((*SwipeMysqlRepository)(nil).FetchWithFilterAndPagination), varargs...)
}

// SingleWithFilter mocks base method.
func (m *SwipeMysqlRepository) SingleWithFilter(ctx context.Context, fields, associate, filter []string, model interface{}, args ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, fields, associate, filter, model}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SingleWithFilter", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SingleWithFilter indicates an expected call of SingleWithFilter.
func (mr *SwipeMysqlRepositoryMockRecorder) SingleWithFilter(ctx, fields, associate, filter, model interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, fields, associate, filter, model}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SingleWithFilter", reflect.TypeOf((*SwipeMysqlRepository)(nil).SingleWithFilter), varargs...)
}

// SoftDelete mocks base method.
func (m *SwipeMysqlRepository) SoftDelete(ctx context.Context, id int) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SoftDelete", ctx, id)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SoftDelete indicates an expected call of SoftDelete.
func (mr *SwipeMysqlRepositoryMockRecorder) SoftDelete(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SoftDelete", reflect.TypeOf((*SwipeMysqlRepository)(nil).SoftDelete), ctx, id)
}

// Store mocks base method.
func (m *SwipeMysqlRepository) Store(ctx context.Context, data domain.Swipe) (domain.Swipe, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Store", ctx, data)
	ret0, _ := ret[0].(domain.Swipe)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Store indicates an expected call of Store.
func (mr *SwipeMysqlRepositoryMockRecorder) Store(ctx, data interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Store", reflect.TypeOf((*SwipeMysqlRepository)(nil).Store), ctx, data)
}

// StoreWithTx mocks base method.
func (m *SwipeMysqlRepository) StoreWithTx(ctx context.Context, tx *gorm.DB, data domain.Swipe) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreWithTx", ctx, tx, data)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StoreWithTx indicates an expected call of StoreWithTx.
func (mr *SwipeMysqlRepositoryMockRecorder) StoreWithTx(ctx, tx, data interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreWithTx", reflect.TypeOf((*SwipeMysqlRepository)(nil).StoreWithTx), ctx, tx, data)
}

// Update mocks base method.
func (m *SwipeMysqlRepository) Update(ctx context.Context, data domain.Swipe) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, data)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *SwipeMysqlRepositoryMockRecorder) Update(ctx, data interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*SwipeMysqlRepository)(nil).Update), ctx, data)
}

// UpdateSelectedField mocks base method.
func (m *SwipeMysqlRepository) UpdateSelectedField(ctx context.Context, field []string, values map[string]interface{}, id int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateSelectedField", ctx, field, values, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateSelectedField indicates an expected call of UpdateSelectedField.
func (mr *SwipeMysqlRepositoryMockRecorder) UpdateSelectedField(ctx, field, values, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateSelectedField", reflect.TypeOf((*SwipeMysqlRepository)(nil).UpdateSelectedField), ctx, field, values, id)
}

// UpdateSelectedFieldWithTx mocks base method.
func (m *SwipeMysqlRepository) UpdateSelectedFieldWithTx(ctx context.Context, tx *gorm.DB, field []string, values map[string]interface{}, id int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateSelectedFieldWithTx", ctx, tx, field, values, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateSelectedFieldWithTx indicates an expected call of UpdateSelectedFieldWithTx.
func (mr *SwipeMysqlRepositoryMockRecorder) UpdateSelectedFieldWithTx(ctx, tx, field, values, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateSelectedFieldWithTx", reflect.TypeOf((*SwipeMysqlRepository)(nil).UpdateSelectedFieldWithTx), ctx, tx, field, values, id)
}

// Upsert mocks base method.
func (m *SwipeMysqlRepository) Upsert(ctx context.Context, onConflictField []string, data ...domain.Swipe) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, onConflictField}
	for _, a := range data {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Upsert", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Upsert indicates an expected call of Upsert.
func (mr *SwipeMysqlRepositoryMockRecorder) Upsert(ctx, onConflictField interface{}, data ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, onConflictField}, data...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*SwipeMysqlRepository)(nil).Upsert), varargs...)
}

